%************************************************
\chapter{Automatic Subscription Handling}\label{ch:automaticsubscription}
%************************************************

After defining the functionality provided to the user of flexible event subscription, this chapter describes the changes necessary to the software infrastructure that is used for event-driven business process management.
The concept requires that all subscription and event handling is executed by the system itself, without further interaction by the user.
All necessary information for that purpose is provided by the BPMN model.

As described in REF, an event-driven process management setup primarily consists of ...
\todo[inline]{missingref}
Changes are necessary to both, the Event Processing Module and the Process Engine. This chapter attempts to keep the change descriptions general so they can be applied to any common process engine and event processing platform.
The first section describes the necessary extension to the event processing to support early subscription and event buffering.
The following section~\autoref{ch:extendedprocessengine} specifies the changes necessary to the behavior of the process engine as the connecting element between the BPMN model and the event processing platform.

\section{Buffered Event Processing}
When reduced to the basics, a standard event processing platform works as follows: The user subscribes to events providing an event query and a notification-path. The platform responds with a unique identifier for that subscription.
Whenever an event occurs that matches the provided query, the platform issues a notification to the notification-path. Subscriptions can be deleted through their unique identifier.
These two operations, \textit{subscribe} and \textit{unsubscribe}, make the fundamental API of a CEP platform.
\todo[inline]{ref} \todo[inline]{Maybe: we consider these two operations as given, because common event processing platforms have these in common, but there is not common event buffering concept yet. even though e.g. esper has something which goes in that direction: output clauses}


\paragraph{An API for buffered Event Processing}
The novel BPMN extension for flexible event subscription allows to issue a subscription for buffering well before the events ought to be delivered via the notification-path. The introduction of an event buffer as a separate entity between the varying list of notification-recipients and the event query makes an extension of the API necessary.
Firstly, the \textit{subscribe} operation has to be divided into two steps:

\begin{aenumerate}
	\item \textit{registerQuery}, registers an event query and instantiates a buffer according to the specified buffer policies. Matching events will be held in the buffer if necessary.
	\item \textit{requestEvents}, provides the notification-path and initiates the delivery of messages via the given path.
\end{aenumerate}\label{def:apiextension-subscribe}

A similar situation holds for the un-subscribe operation: Traditionally, a subscription is canceled through a unique identifier that is obtained as a result of the subscribe operation. After cancellation, no more notifications are delivered, the query is removed from the system.
Given flexible event subscription, this operation must be split into two parts as well:

\begin{aenumerate}
	\item \textit{unsubscribe} method removes a notification-recipient for a given query-id
	\item \textit{remove query} operation deletes the query and the buffer.
\end{aenumerate}\label{def:apiextension-unsubscribe}

Only if all four methods are available, it is possible to execute the subscription on process deployment.
The query must be registered using \textit{registerQuery} before the process instance, i.~e. notification-path, is available. For each process instance, events can be requested individually using \textit{requestEvents} and thereafter, the notification-recipient can be removed with \textit{unsubscribe}.
The query and its buffer will remain active even after any single instance has terminated. When the process gets un-deployed, the query can be deleted using \textit{remove query}.
Section~\autoref{ch:extendedprocessengine} describes the steps in detail.


- a call registerQuery(queryString [, bufferPolicies]): queryId, 
> it does ...
> if the notificationpath is provided...
> it returns. unique identifier. must be stored for later management of that query
- a call requestEvent(queryId, notificationPath),
> ...
> requestEvents is not the same as addNotificationRecepient
- a call unsubscribe(queryId)
> ...
- a call deleteQuery(queryId)
> ...

\missingfigure{maybe a uml sequence diagram. Or other diagram format?}
\todo[inline]{maybe provide a swagger definition for this?}

\paragraph{Different options to implement the API extension}

That extension can either be implemented by adopting the CEP platform itself, by implementing a separate middleware between process engine and CEP platform, or by implementing a buffering module as part of the process engine.
Which of the three options suits best has to be evaluated for the given use-case and existing infrastructure. In some cases it might not be possible to adapt the code of process engine or event processing platform, which leaves a separate middleware as the only choice.
\todo[inline]{Generally, extending the event processing platform is advisable? Or put up brief pros and cons of each of the options}
\missingfigure{three options to implement the event buffering and api extension}

A reference implementation for an extended complex event processing platform is presented in chapter~\autoref{ch:implementation} at the example of the Esper-based CEP platform \textit{Unicorn}. It is also explained, why extending the event platform was the preferred choice in the given scenario.

\paragraph{Performance Considerations}
- performance improvements through shared windows
- due to its performance optimizations, an extension of the cep itself would make perfect sense
- given the extended api, it is now possible to implement early event subscription from the process engine 


\section{Extended Process Engine Behaviour}\label{ch:extendedprocessengine}
It is the task of the Business Process Engine to interpret and execute process models and connect to an event processing platform in event-driven setups.
From the three relevant modules, two have already been defined, the BPMN extension and the buffered event processing module.
Out of the box, a process engine like Camunda will ignore any proprietary BPMN extensions and the subscription to an event source must be especially implemented. An example for such an implementation is provided in section~\autoref{ch:assessment-implementation}.
One goal of this work is to automatize the handling of event subscriptions solely based on the information available through extended BPMN model. Additional process elements are not required.

- read extended information from the model, extended message and explicit subscription task

- implement the subscription time
> on deployment
> on instantiation
> at service task
> when event element is reached
> store the queryId, buffer scope: correlates with the subscription time. is relevant if working with consume messages. Later reuse of the queryId

- implement the requestEvent
> when event element is reached

- implement the unsubscription
> when event element is finished

- implement the deletion of the query
> when event element is finished
> when a process is undeployed
> there must be a "subscription-garbage-collection" for any events that cannot be reached anymore in the current process execution! e.g. two different events behind an xor-gateway. the garbage collection could be executed on every transition


- handling subscription dependencies:
- The use of dynamic process variable values introduces an additional complexity: Depending on the time of event subscription, the value of the process variable might not yet be available.
- reference BPMN data elements: process INSTANCE variable
-> the variable value might only be available during instance execution
-> can we find an exact definition of this in the spec?
- see BPMN2 spec pp.211+ : Process and Activity can have DataInput and DataOutput. DataInput can have an 'optional' attribute
- during execution the variable data might or might not be available. Related Work: Francesca?
-> too complex, we need a simplification for this.
- what happens if the data is not available?

