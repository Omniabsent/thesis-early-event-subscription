\section{BPMN Extension}\label{ch:bpmnx}

\todo[inline]{this is the explanation for the process designer? or is there an additional event engineer?}

Given the additional requirements and the shortcomings identified in the previous sections, the following two chapters present an extension to the BPMN event handling model.
At first, an extension to the Business Process Model and Notation (BPMN) is described, which aims at providing the Process~Designer with more flexible Event Handling capabilities according to Requirement~\textit{R1}.
Afterwards, \autoref{ch:automaticsubscription} clarifies the changes necessary to the event handling platform and the process engine to cover Requirements \textit{R2} and \textit{R3}.
While the presented concepts are kept as general as possible, they are grounded in an analysis of the Esper-based CEP Platform Unicorn and the open-source process engine Camunda.

The extensibility mechanism allows to extend standard BPMN elements with additional attributes, while maintaining a valid BPMN core.
Extensions are specified through an external definitions file and can be included into a BPMN process model by reference.
To allow the flexible use of event subscription in BPMN models, a number of additional attributes must be added to BPMN process models.

The presented extension is designed for use with intermediate catch events, boundary events and receive tasks. Start events and End events are not considered because flexible subscription time is not relevant in these cases.
% receiveTask.messageRef; boundaryEvent.catchEvent.(message)eventDefinition.messageRef; intermediateCatchEvent.catchEvent.(message)eventDefinition.messageRef
Each of the three elements references a BPMN \textit{Message}, the common denominator for communication within and across business processes.
Semantically, the \textit{Message} type is most suited to be extended with subscription information.

\todo[inline]{mention that others have extended the events instead, but this proposal goes another way}

\missingfigure{A UML diagram of Message, MessageFlow, MessageEventDefinition, Catch Event, Boundary Event, ReceiveTask}

\todo[inline]{explain that the Message is a common element in BPMN models. It is the main generic type used for communication, collaboration.
The proposed extension to the Message type is only to be used by Message Receive situations in Intermediate Catch Event, the Boundary Catch Event and the Receive Task.}

By specification, \textit{tMessage} comprises an attribute \textit{name}, the name of the message, and \textit{itemRef}, the reference to a BPMN \textit{ItemDefinition}. Additionally, it inherits all attributes from the BPMN \textit{RootElement}.
In the following, the required additional attributes will be explained one after the other. A complete list is available in \autoref{tab:bpmn-extension}. The goal is to retain a stand-alone model that contains all information necessary to execute the subscription to the event source.

\begin{table}
	\myfloatalign
	\begin{tabularx}{\textwidth}{p{0.3\linewidth} p{0.4\linewidth} p{0.2\linewidth}}
		\toprule
		\tableheadline{Attribute Name} & \tableheadline{Value Options (\underline{default})} & \tableheadline{Optional} \\ 
		\midrule
		eventQuery & any string & n \\
		subscriptionTime & process-deployment, process-instantiation, \underline{event-reached} & y \\
		bufferPolicies & Complex Type (see below) & y \\
		
		\midrule
		\tableheadline{bufferPolicies}  \\
		\midrule
		
		LifetimePolicy & string in ISO time-span format OR '\underline{infinite}' & y \\
		ConsumptionPolicy & \underline{Reuse}, Bounded-Reuse(n), Consume & y \\
		SizePolicy & int (< 1 for infinite), \underline{1} & y \\
		OrderPolicy & \underline{FIFO}, LIFO & y \\
		
		\bottomrule
	\end{tabularx}
	\caption[]{Available attributes in the BPMN extension for flexible event subscription}  \label{tab:bpmn-extension}
\end{table}


\subsection{Adding basic subscription information}\label{ch:bpmnx:basic}

For a basic event subscription, an event~query, the platform address and optionally authorization information of the CEP~Platform is required. \todo[inline]{ref background}
It is assumed that only one CEP platform is in use, whose access information is configured centrally for the current process execution environment. Consequently, there is no need to specify these two parameters on message level. 
The event query instead needs to be specified for every message and is added to the model as an extension attribute \textit{eventQuery} of type \textit{String}, which should contain the full query as interpretable by the CEP platform.

A similar approach has been taken by X and Y, who aim at enriching BPMN models with subscription information without considering the time of subscription specifically.
\todo[inline]{Find this source; explain what they do (different)}

Given this first fundamental part of the BPMN extension, it is possible to execute the subscription, but the time of subscription cannot be influenced.

\subsection{The time of event subscription modeled in BPMN}\label{ch:bpmnx:subscriptiontimes}

This section specifically addresses the requirement \textit{R1.1}, aiming to provide a flexible event subscription time to be selected for each BPMN message when designing an event-driven process.
Two different tools are to be offered to support all subscription times demanded by \textit{R1.1}: Firstly, the subscription can happen in the background . Alternatively, the subscription can be modeled explicitly as a flow-element in the process.
It is the task of the process designer to elaborate the correct time of subscription necessary for her use case.

The subscription will be executed automatically by the system based on the information given in the BPMN model. Further information on the exact execution flow is provided in chapter~XY.

\paragraph{Introducing Event Buffers}
Any event message that occurs before reaching the event element but after the time of subscription will be kept in a buffer by the system.
In its simplest version, the buffer is of length 1, that means it stores exactly one message received from a CEP platform. It always stores the latest message. When a newer message arrives, the old one is replaced in the buffer.
\autoref{ch:bpmnx:bufferpolicies} introduces a set of advanced buffer policies to adapt this behavior further.
\todo[inline]{By default, there is no interference between the buffers of different messages, process instances or processes. Each buffer instance will contain the latest information as if it was the only buffer in the system. Performance improvements to avoid duplicate buffer content will be managed by the system without explicit action by the user. Section ... later introduces a shared, more complex usage scenario of the event buffers.}


\paragraph{Interplay of Event Queries and Buffers}
Modern event query languages are feature-rich and offer a large set of expressions to filter events from incoming streams. \todo[inline]{ref background}
The introduced basic event buffer can be used in connection with any desired event query and will store the latest output of that query.
These two features together suffice to implement even more complex use-cases: Query windows of length \textit{n} can be used to keep multiple events in the buffer, filter expressions allow to keep a subset of all events based on their attribute values, multiple streams can be joined together.
As soon as the process flow reaches an event element, the latest CEP message is retrieved from the buffer. It is not consumed, that means a second event element that references the same BPMN Message will reuse the information from the buffer.
If no information is available in the buffer, the flow element will remain in the waiting state until a message is received. Then, the process flow proceeds as usual.

\todo[inline]{reorganize this chapter}

\paragraph{Subscription time as part of the BPMN Message element\newline}
To provide the Process Designer with a simple but powerful tool to influence the time of event subscription, a field \textit{subscriptionTime} is added the BPMN message element. 
The field can take one of the following three values: \textit{Process Deployment}, \textit{Process Instantiation}, \textit{Event reached}. The last option is the default option, coming closest to the BPMN specification.
Note that a \textit{subscriptionTime} set to \textit{Event reached} will remain without effect if an explicit subscription task for the same event was executed before the event is reached.

\todo[inline]{For each of the options: Define exactly (according to BPMN spec or standard literature), when in the flow the subscription is executed.}

In motivating Example~Ex, it is necessary to issue the subscription as early as possible, to make sure that data is available and the process execution is not delayed. \todo[inline]{which example to reference?}
Using the BPMN extension, the use case can be implemented by defining the event query and the subscription time in the BPMN model. \todo[inline]{show what that would look like in the example. Maybe some XML?}

\paragraph{The explicit subscription task\newline}
As an alternative to specifying the subscription time using the extension field \textit{subscriptionTime} of \textit{tMessage}, an extension to the BPMN ServiceTask is proposed. \todo[inline]{it follows the ideas presented in ... but through referencing the message element}

\missingfigure{Example 2 using an explicit subscription task}

The extended task is used to execute the subscription explicitly as part of the process flow.
A field \textit{messageId} is added to the service task to establish a reference between the activity and the message definition.
As introduced in section~\autoref{ch:bpmnx:basic}, the extended BPMN Message definition contains the information necessary to issue the subscription to an event source.
Once the Explicit Subscription Task is activated, the subscription for the referenced message is issued. 

Modeling the event subscription in an explicit task can be necessary when the subscription depends on the result of another activity. In that case, the subscription cannot be issued on process instantiation, because the necessary information is not yet available. Instead, an early subscription can be implemented using the extended service task.
Apart from this particular use case, the explicit subscription task enables the Process Designer to place the subscription flexibly in the process flow and give her full control over the time of subscription.

\todo[inline]{As an improvement to the options for subscription time, there could be an option "ASAP", so that the process engine issues the subscription automatically as soon as the required process data becomes available}

If both tools, the extension field \textit{subscriptionTime} and the explicit subscription task, are used for a single BPMN message, the earlier subscription of the two will be executed, the second subscription will have no effect.
That means for example if the \textit{subscriptionTime} is set to \textit{event reached} and an explicit subscription task is inserted before the event element, then the subscription will be executed at the time the explicit subscription task is active.
If \textit{subscriptionTime} is set to \textit{Process Deployment}, then the subscription will happen at that time and the explicit subscription task will remain without effect.
In case neither of the two is used, the system falls back to the BPMN default and executes the subscription when the event element is reached.

\subsection{Using Process Variables in Event Queries}

\todo[inline]{this could be added in the requirements and referenced}

% also see bpmn2 spec 10.3 pp. 233ff.

As shown in example~Z, it can be the case that the values of process variables shall be dynamically used in an event query.
Therefore, the name of the process variable should be part of the event query. At the time of subscription, the mentioned variable is dynamically replaced by its current value.
The exact notation for including process variables in event queries can vary depending on the applied query language as it may not interfere with any existing notation schemes.
For the use with the Esper query language, the following is suggested: The exact name of the variable has to be surrounded by curly brackets and preceded by a \textit{\#} character: \textit{\#\{VARIABLENAME\}}.
This notation is inspired by the usage of substitution parameters in SQL queries that are embedded in Esper. They take the form \textit{\$\{expression\}}.
\todo[inline]{reference esper docs 5.13.1. Joining SQL Query Results}

In the example, the process uses the latest GPS position for a certain truck. The truck is identified by its unique~ID which is part of the query: \textit{SELECT lat, lng from GPSUPDATE where truckid = \#\{truckid\} }.
\todo[inline]{missingref: dependent example}

The use of dynamic process variable values introduces an additional complexity: Depending on the time of event subscription, the value of the process variable might not yet be available.
\todo[inline]{What does this mean for the process designer? A model that can take a state in that a subscription shall be issued, though the data is unavailable, is invalid. When will an error occur? }


\subsection{Advanced Buffer Parameters}\label{ch:bpmnx:bufferpolicies}
Inspired by \citeauthor{mandal:2017} \citep{mandal:2017}, a number of advanced buffer attributes are available through an extension attribute \textit{bufferPolicies}.
\todo[inline]{add ref to sankalitas paper; do I elaborate on the changes made in comparison to the paper? + the reasons?}
 

\paragraph{Life-time of buffered events\newline}

The \textit{LifetimePolicy} allows to specify after which timespan elements in the buffer should be deleted. Timespans shall be defined using ISO timespan format. \todo[inline]{ref external}
The default value is \textit{infinite}.
Example A has been implemented by setting the \textit{subscriptionTime} to \textit{Process Deployment}, which means that there can be an infinite time difference between the action of subscribing to the event source and the reaching of the event element in one of the instances. \todo[inline]{ref example}
In case events are not published in a longer time, for example due to technical fault at the event producer, the buffer will contain older events that might not be relevant anymore.
Using the \textit{LifetimePolicy}, the process designer can express, that events should be deleted from the buffer after a certain period of time and thus avoid outdated information. The buffer is maintained automatically by the system.
That of course comes at the price that the process has to remain in waiting state until a new event message arrives.

\paragraph{Consumption Behavior\newline}
\todo[inline]{for the reader it would not be clear, what a 'buffer instance' is}
So far, the event buffers can be used isolated from each other. There is no interference between buffer instances and events are not removed from the buffer after retrieval.
While for most use-cases this behavior is sufficient, more detailed control over the buffer can be desirable when a given message shall be used multiple times.
Not always is it wanted, that events remain in the buffer after retrieval.
An additional parameter \textit{ConsumptionPolicy} is introduced which can take the values \textit{Consume}, \textit{Reuse}(default) and \textit{Bounded Reuse(n)}.
While \textit{Reuse} denotes the behavior that is already known, \textit{Bounded Reuse(n)} will allow an element to be retrieved exactly \textit{n} times. \textit{n} has to be replaced by an integer value greater 0.
The option \textit{Consume} will remove an element from the buffer immediately after it has been retrieved for the first time, it is therefor equivalent to \textit{Bounded Reuse(1)}.


\begin{figure}[]
	\myfloatalign
	{\includegraphics[width=1\linewidth]{chapters/concept/bpmnx/FlightBooking.png}}
	\caption{Flight Booking process using a consuming buffer}\label{fig:example-flightbooking}
\end{figure}



- given the option to consume from the buffer, it will now make a difference if the same buffer is accessed multiple times.
- there are two scenarios to access the same buffer: (1) multiple times in the same instance, (2) multiple times because of parallel instances, (3) multiple times because of a shared buffer across processes
- before proceding, we need to be clear about the buffer scope: it depends on the time of subscription. (1) after instantiation: buffer only instance-wide; (2) on pr depl: buffer reused across all instances; (3) system start: buffer reused across all processes

\begin{figure}[]
	\myfloatalign
	{\includegraphics[width=1\linewidth]{chapters/concept/bpmnx/ComplaintProcessing.png}}
	\caption{Shared consuming buffer in Complaints Handling}\label{fig:example-complaints}
\end{figure}

\paragraph{Buffer Size and Order Policy\newline}

- two additional buffer policies: \textit{SizePolicy}, \textit{OrderPolicy}, default values
\todo[inline]{write text for given keypoints}

- what if messages are defined in different ways? => I want to reuse the buffer between processes, but the message definition (especially cep query) are not the same. how will the system behave?
